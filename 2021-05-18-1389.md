---
title: "[BOJ]백준 1389번 - 케빈 베이컨의 6단계 법칙"
excerpt: "또익스트라"

date: 2021-05-18 17:22 +0900
categories:
    - BOJ
tags:
    - [백준]
---

#### 문제링크
---
Link: <http://icpc.me/1389>

#### 분류
---
+ Silver I
+ Dijkstra

#### 풀이
---

이 또한 다익스트라로 모든 정점까지의 최단거리를 구하고 그의 합끼리 비교해서 idx를 정하면 된다. n이 100까진가? 밖에 안되기 때문에 모든 정점을 대상으로 다익스트라를 돌릴 수 있다. 더 쓸 게 없는 게 쉽고, 느낀 점이 딱히 없당.

```cpp
#include <bits/stdc++.h>
#define MAXN 100
using namespace std;

int n, m;
vector<int> adj[MAXN+1];
vector<int> ans;
int dijkstra(int x){
    vector<int> dp(n+1, INT_MAX);
    dp[x] = 0;

    priority_queue<pair<int, int>> pq;
    pq.push({0, x});

    while(!pq.empty()){
        int here = pq.top().second;
        int cost = -pq.top().first;
        pq.pop();
        if(cost > dp[here]) continue;
        for(auto there: adj[here]){
            int nextCost = 1 + cost;
            if(nextCost < dp[there]){
                dp[there] = nextCost;
                pq.push({-nextCost, there});
            }
        }
    }
    return accumulate(dp.begin()+1, dp.end(), 0);
}
int main(void){
    cin >> n >> m;
    for(int i=0; i<m; i++){
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    ans.resize(n+1, 0);
    int min = INT_MAX;
    int midx = -1;
    for(int i=1; i<=n; i++){
        ans[i] = dijkstra(i);
        if(ans[i] < min){
            min = ans[i];
            midx = i;
        }
    }
    cout << midx;
    return 0;
}
```