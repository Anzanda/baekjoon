---
title: "[BOJ]백준 2842번 - 집배원 한상덕"
excerpt: "투 포인터?"

date: 2021-05-19 17:48 +0900
tags:
    - BOJ
categories:
    - [백준, NPC, DFS, 투포인터]
    
---

### 문제링크
---
Link: <http://icpc.me/2842>

### 분류
---
+ Platinum V
+ 투 포인터, DFS

### 풀이
---

한상덕씨가 우체국에서 배달을 한다. 이 사람이 움직이는 동선에서 높이의 최댓값 - 최솟값을 `피로도`라고 했을 때 피로도의 최솟값을 구하는 문제이다.

##### 1. parametric search
---
이 문제는 parametric search로 환원해서 풀 수 있다. 재해석 해보자면 [a,b]라는 범위에서 배달을 할 수 있을 때 `b-a`의 최소를 구해라 라는 문제인 것이다. 그리고 이는 이렇게 풀 수 있다. b를 1부터 `tired.size()`까지 증가시키면서 a를 parametric search로 최댓값을 구하고, b-a의 값을 min에 업데이트 하는 것이다. parametric search를 사용하기 때문에 복잡도는 O(nlogn)이 될 거 같다!
```cpp
#include <bits/stdc++.h>

#define MAXN 50
using namespace std;

int n;
int sr, sc;
vector<pair<int,int>> house;
int height[MAXN][MAXN];
vector<int> tired;
int high, low;
bool vst[MAXN][MAXN];
void dfs(int x, int y){
    if(x<0 || x >=n || y<0 || y>=n || height[x][y] < tired[low] || height[x][y] > tired[high]){
        return;
    }
    if(vst[x][y])   return;
    vst[x][y] = true;
    for(int i=-1; i<=1; i++){
        for(int j=-1; j<=1; j++){
            if(i==0 && j==0)    continue;
            int nx = x + i;
            int ny = y + j;
            dfs(nx, ny);
        }
    }
}
bool checkIsValid(){
    memset(vst, false, sizeof vst);
    dfs(sr,sc);
    for(auto it=house.begin(); it != house.end(); it++){
        if(!vst[it->first][it->second])
            return false;
    }
    return true;
}
int main(void){
    cin >> n;
    for(int i=0; i<n; i++){
        char c[MAXN];
        cin >> c;
        for(int j=0; j<n; j++){
            if(c[j] == 'K'){
                house.push_back({i,j});
            }
            if(c[j] == 'P'){
                sr = i;
                sc = j;
            }
        }   
    }
    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            cin >> height[i][j];
            tired.push_back(height[i][j]);
        }
    }
    sort(tired.begin(), tired.end());
    tired.erase(unique(tired.begin(), tired.end()), tired.end());

    int min=INT_MAX;
    high = 0; low=0;
    while(high < tired.size()){
        int l,r,mid;
        l = 0;
        r = high;
        while(l<r){
            mid = (l+r+1)/2;
            low=mid;
            if(checkIsValid()){
                l = mid;
                min = min > (tired[high]-tired[low]) ? (tired[high]-tired[low]) : min;
            }
            else{
                r = mid-1;
            }
        }
        low = l;
        if(checkIsValid()){
            min = min > (tired[high]-tired[low]) ? (tired[high]-tired[low]) : min;
        }
        high++;
    }
    cout << min;
    return 0;
}
```
나는 이렇게 풀려다가 결국 투 포인터를 이용해서 풀었다. 풀고나니까 투 포인터라는 이름이 있는 알고리즘이더라. 위에는 승재님 코드 참고해서 적은 코드.

### 2. 투 포인터
---

고민을 헀던 게 어떻게 이 범위를 야무지게 잘 쓸 수 있을 까? 에 대한 고민이었다.